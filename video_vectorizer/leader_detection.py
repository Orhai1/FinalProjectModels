# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lQu2nS0No3c9iXMY2HQvaYDygG7aGHwU
"""


import os
import cv2
import torch
import json
import numpy as np
import torch.nn.functional as F
from insightface.app import FaceAnalysis
import torch.nn as nn

class LeaderClassifier(nn.Module):
    def __init__(self, input_dim=512, hidden_dim=128, output_dim=8):
        super(LeaderClassifier, self).__init__()
        self.net = nn.Sequential(
            nn.Linear(input_dim, hidden_dim),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(hidden_dim, output_dim)
        )
    def forward(self, x):
        return self.net(x)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

from google.colab import drive
drive.mount('/content/drive')

with open("/content/drive/MyDrive/video_vectorizer/leader_classes.json") as f:
    class_names = json.load(f)

model = LeaderClassifier(output_dim=len(class_names)).to(device)
model.load_state_dict(torch.load("/content/drive/MyDrive/video_vectorizer/leader_model.pt"))
model.eval()

app = FaceAnalysis(name="buffalo_l", root="/root/.insightface", providers=["CUDAExecutionProvider"])
app.prepare(ctx_id=0)


def detect_leaders_in_frames(frames_dir):
    detected = {f'leader_{name}': 0 for name in class_names}
    metadata = []

    for fname in sorted(os.listdir(frames_dir)):
        path = os.path.join(frames_dir, fname)
        if not os.path.isfile(path) or not fname.lower().endswith((".jpg", ".png")):
            continue

        img = cv2.imread(path)
        if img is None:
            print(f" Skipped unreadable image: {fname}")
            continue

        try:
            faces = app.get(img)
            print(f"{fname} - Found {len(faces)} faces")

            for face in faces:
                emb = torch.tensor(face.embedding, dtype=torch.float32).unsqueeze(0).to(device)

                with torch.no_grad():
                    out = model(emb)
                    pred = torch.argmax(F.softmax(out, dim=1), dim=1).item()
                    class_name = class_names[pred]
                    detected[f'leader_{class_name}'] = 1
                    print(f" Predicted: {class_name}")
                    metadata.append({
                        "label": class_name,
                        "frame": fname,
                        "bbox": face.bbox,
                        "confidence": float(F.softmax(out, dim=1)[0][pred])
                    })

        except Exception as e:
            print(f"Error processing {fname}: {e}")

    #print("Final leader vector:", detected)
    return detected, metadata
