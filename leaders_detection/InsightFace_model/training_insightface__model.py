# -*- coding: utf-8 -*-
"""InsightFace _model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19dCNZLXmuUq-1cBRb8f-D9uHemfBLwfg
"""

!rm -rf /root/.insightface/models/antelopev2

!pip install -U insightface==0.7

from google.colab import drive
drive.mount('/content/drive')

train_dir = "/content/drive/MyDrive/training_set/training_set"
test_dir = "/content/drive/MyDrive/test_set/test_set"
model_path = "/content/drive/MyDrive/leader_model.pt"
class_names_path = "/content/drive/MyDrive/leader_classes.json"

import shutil
import zipfile
import os

zip_path = "/content/drive/MyDrive/buffalo_l.zip"

model_dir = "/root/.insightface/models/buffalo_l"

os.makedirs(model_dir, exist_ok=True)

with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(model_dir)

print("‚úÖ Model extracted successfully")

import os
import cv2
import numpy as np
from tqdm import tqdm
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import TensorDataset, DataLoader
from sklearn.preprocessing import LabelEncoder
import joblib

!pip install onnxruntime-gpu

from insightface.app import FaceAnalysis

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

app = FaceAnalysis(name="buffalo_l", root="/root/.insightface", providers=["CUDAExecutionProvider"])
app.prepare(ctx_id=0)

def build_data(folder_path):
    X, y = [], []
    class_names = sorted(os.listdir(folder_path))
    class_to_idx = {name.lower(): i for i, name in enumerate(class_names)}

    for label in tqdm(class_names):
        label_path = os.path.join(folder_path, label)
        if not os.path.isdir(label_path):
            continue

        for fname in os.listdir(label_path):
            if not fname.lower().endswith((".jpg", ".png")):
                continue

            img_path = os.path.join(label_path, fname)
            img = cv2.imread(img_path)
            if img is None:
                continue

            faces = app.get(img)
            for face in faces:
                X.append(face.embedding)
                y.append(class_to_idx[label.lower()])

    return np.array(X, dtype=np.float32), np.array(y), class_names

# PyTorch model
import torch
import torch.nn as nn

class LeaderClassifier(nn.Module):
    def __init__(self, input_dim=512, hidden_dim=128, output_dim=8):
        super(LeaderClassifier, self).__init__()
        self.net = nn.Sequential(
            nn.Linear(input_dim, hidden_dim),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(hidden_dim, output_dim)
        )

    def forward(self, x):
        return self.net(x)

from sklearn.model_selection import train_test_split
from torch.utils.data import TensorDataset, DataLoader
import json

# data
X_train, y_train, class_names = build_data(train_dir)
X_test, y_test, _ = build_data(test_dir)

# Tensors
train_ds = TensorDataset(torch.tensor(X_train), torch.tensor(y_train))
train_loader = DataLoader(train_ds, batch_size=32, shuffle=True)

# initiallize the model
model = LeaderClassifier(input_dim=512, output_dim=len(class_names)).to("cuda")
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

# training
for epoch in range(10):
    model.train()
    total_loss = 0
    for xb, yb in train_loader:
        xb, yb = xb.to("cuda"), yb.to("cuda")
        optimizer.zero_grad()
        out = model(xb)
        loss = criterion(out, yb)
        loss.backward()
        optimizer.step()
        total_loss += loss.item()
    print(f"‚úÖ Epoch {epoch+1}: loss = {total_loss:.4f}")

# saving the model
torch.save(model.state_dict(), model_path)

with open(class_names_path, "w") as f:
    json.dump(class_names, f)

print("‚úÖ ◊î◊û◊ï◊ì◊ú ◊†◊©◊û◊® ◊ë◊î◊¶◊ú◊ó◊î (pt + class names)")

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import matplotlib.pyplot as plt

# Tensor
X_test_tensor = torch.tensor(X_test, dtype=torch.float32).to("cuda")

# using the model
model.eval()
with torch.no_grad():
    outputs = model(X_test_tensor)
    predictions = torch.argmax(outputs, dim=1).cpu().numpy()


accuracy = accuracy_score(y_test, predictions)
precision = precision_score(y_test, predictions, average='weighted')
recall = recall_score(y_test, predictions, average='weighted')
f1 = f1_score(y_test, predictions, average='weighted')

# gragh
metrics = [accuracy, precision, recall, f1]
labels = ['Accuracy', 'Precision', 'Recall', 'F1 Score']

plt.figure(figsize=(5, 3))
plt.bar(labels, metrics, color='mediumseagreen')
plt.ylim(0, 1)
plt.title("Leader Classification")
plt.ylabel("Score")
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

print(f"‚úÖ Accuracy:  {accuracy:.4f}")
print(f"üéØ Precision: {precision:.4f}")
print(f"üì¢ Recall:    {recall:.4f}")
print(f"üèÜ F1 Score:  {f1:.4f}")

import numpy as np

#gragh each leader
per_class_counts = {name: {"total": 0, "correct": 0} for name in class_names}

for true, pred in zip(y_test, predictions):
    class_name = class_names[true]
    per_class_counts[class_name]["total"] += 1
    if true == pred:
        per_class_counts[class_name]["correct"] += 1

class_accuracies = {
    name: round(info["correct"] / info["total"], 3)
    for name, info in per_class_counts.items()
}

plt.figure(figsize=(8, 4))
plt.bar(class_accuracies.keys(), class_accuracies.values(), color='steelblue')
plt.ylim(0, 1)
plt.xticks(rotation=45)
plt.title("Accuracy per Leader")
plt.ylabel("Accuracy")
plt.tight_layout()
plt.show()


for name, acc in class_accuracies.items():
    print(f"{name:12s} : {acc*100:.1f}%")